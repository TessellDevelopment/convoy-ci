---
name: Tessell Pipelines Code Build Pre Merge
on:
  workflow_call:
    inputs:
      type:
        description: 'This is used to determine build type'
        required: true
        type: string

jobs:

  build-ui:
    if: ${{ inputs.type == 'ui-build' }}
    runs-on: ui-build
    env:
      NEXUS_REPO_NPM: tessell-repos-npm-development
      NEXUS_PULL_REPOS_M2: tessell-m2-development
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_PUBLIC}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_PUBLIC}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Build
        shell: bash
        run: |
          gradlewUI() {
            rm ~/.npmrc
            rm ~/.yarnrc
            TOKEN=$(echo -n '${{env.NEXUS_USERNAME}}:${{env.NEXUS_PASSWORD}}' | base64 -w 0)
            echo '"@tessell:registry" "${{env.NEXUS_PROTOCOL}}://${{ env.NEXUS_SERVER_ENDPOINT }}/repository/${{ vars.NEXUS_PUSH_REPOS_NPM }}/"' >> .yarnrc
            echo "always-auth=true" >> .npmrc
            echo "_auth=$TOKEN" >> .npmrc
            cat .npmrc
            cat .yarnrc
            set -e
            ./gradlew zipUiBuild --console plain --stacktrace \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}"
            set +e
          }
          npmBuild() {
            set -e
            npm install
            npm run build
            set +e 
            rm ~/.npmrc
            TOKEN=$(echo -n '${{env.NEXUS_USERNAME}}:${{env.NEXUS_PASSWORD}}' | base64 -w 0)
            echo "//${{ env.NEXUS_SERVER_ENDPOINT }}/repository/:_auth = $TOKEN" >> ~/.npmrc
            echo "//${{ env.NEXUS_SERVER_ENDPOINT }}/repository/:always-auth = true" >> ~/.npmrc 
            echo "@tessell:registry=${{env.NEXUS_PROTOCOL}}://${{ env.NEXUS_SERVER_ENDPOINT }}/repository/${{ env.NEXUS_REPO_NPM }}" >> ~/.npmrc
            cat ~/.npmrc
            set -e
            version="$3"
            yq ".version = \"$version\"" package.json > tmp_package.json
            mv tmp_package.json package.json
            npm publish   
            set +e
          }
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            version=$(yq '.version' convoy.yaml)
            while IFS=$'\t' read -r name buildFunction ext file _; do
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "Version: $version"
              echo "dockerFile: $file"
              $buildFunction "$name" "$ext" "$version" "$file"
            done < <(yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile] | @tsv" convoy.yaml)
          }
          set +e
          build "artifacts"
          build "dockerImages"
          build "helmCharts"
  
  build-ubuntu-latest:
    if: ${{ inputs.type == 'ubuntu-latest' }}
    runs-on: ubuntu-latest
    env:
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_PUBLIC}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_PUBLIC}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Build
        shell: bash
        run: |
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            version=$(yq '.version' convoy.yaml)
            while IFS=$'\t' read -r name buildFunction ext file _; do
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "Version: $version"
              echo "dockerFile: $file"
              $buildFunction "$name" "$ext" "$version" "$file"
            done < <(yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile] | @tsv" convoy.yaml)
          }
          set +e
          build "artifacts"
          build "dockerImages"
          build "helmCharts"

  build-amd:
    if: ${{ inputs.type == 'amd' }}
    runs-on: self-hosted
    env:
      GOPATH: /home/github/go
      NEXUS_PULL_REPOS_M2: tessell-m2-development
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_LOCAL}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_LOCAL}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Check specific file changes
        id: changed-files
        uses: tj-actions/changed-files@v42.0.2
        with:
          files: |
            Chart.yaml
            services/**
            scripts/Dockerfile
            scripts/initializeAutomation.sh

      - name: Check All file changes
        id: changed-files-all
        uses: tj-actions/changed-files@v42.0.2

      - name: Build
        shell: bash
        run: |
          agentBuild() {
            set -e
            installGoDependencies
            ARTIFACT="$1"
            OS=$(echo "$ARTIFACT" | awk -F'[-]' '{print $4}')
            SERVICE=$(echo "$ARTIFACT" | awk -F'[-]' '{print $2}')
            echo $OS
            echo $SERVICE
            echo "Building Service"
            make os=$OS nexus_protocol=${{env.NEXUS_PROTOCOL}} nexus_server_endpoint=${{env.NEXUS_SERVER_ENDPOINT}} $SERVICE
            make clean
            set +e
          }
          createPipConf(){
            set -e
            echo "[global]" > pip.conf
            echo "index =  ${{env.NEXUS_PROTOCOL}}://${{ secrets.CIPIPELINE_NEXUS_USERNAME }}:${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}@${{ env.NEXUS_SERVER_ENDPOINT }}/repository/${{ env.NEXUS_PULL_REPOS_PY }}/simple" >> pip.conf
            echo "index-url = ${{env.NEXUS_PROTOCOL}}://${{ secrets.CIPIPELINE_NEXUS_USERNAME }}:${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}@${{ env.NEXUS_SERVER_ENDPOINT }}/repository/${{ env.NEXUS_PULL_REPOS_PY }}/simple" >> pip.conf
            echo "extra-index-url = https://pypi.org/simple" >> pip.conf
            sudo cp pip.conf /etc/pip.conf
            set +e
          }
          dbPluginBuild() {
            set -e
            ARTIFACT="$1"
            createPipConf
            if [ -f ./$ARTIFACT/requirements.txt ]; then python3 -m pip install -r ./$ARTIFACT/requirements.txt --dry-run --trusted-host ${{env.NEXUS_SERVER_ENDPOINT}}; fi
            lintCheck
            gradlewPythonwheel
          }
          dockerBuild() {
            set -e
            IMAGE_NAME="$1"
            FILE="$4"
            if [[ "$FILE" == "null" || -z "$FILE" ]]; then
              FILE="./Dockerfile"
            fi
            echo "$FILE"
            echo "Starting Docker"
            docker build -f $FILE -t $IMAGE_NAME .
            set +e
          }
          dockerBuildOps() {
            set -e
            mvnwBuild
            dockerBuild "$1" "$2" "$3" "$4"
            set +e
          }
          functionBuild() {
            set -e
            ARTIFACT="$1"
            cd tessell;
            OS=$(echo "$ARTIFACT" | awk -F'[-]' '{print $4}')
            CLOUD=$(echo "$ARTIFACT" | awk -F'[-]' '{print $5}')
            echo $OS
            echo $CLOUD
            make OS=$OS CLOUD=$CLOUD nexus_protocol=${{env.NEXUS_PROTOCOL}} nexus_server_endpoint=${{env.NEXUS_SERVER_ENDPOINT}} package
            cd ..
            set +e
          }
          gradlewMaven() {
            set -e
            echo ./gradlew mavenPackage --refresh-dependencies --console plain \
              -Pnexus_push_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_push_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}"
            set +e
          }
          gradlewPythonwheel() {
            set -e
            ./gradlew pythonWheel --console plain \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}"
            set +e
          }
          helmChart(){
            set -e
            CHART_NAME="$1"
            cd scripts
            ./package-and-push --no-push -n $CHART_NAME
            set +e
          }
          helmTemplate() {
            if [[ ${{steps.changed-files.outputs.any_modified}} == 'true' ]]; then
              CHART_NAME="$1"
              GITHUB_WORKSPACE=$(pwd)
              CHART_GITHUB_LOCATION=$GITHUB_WORKSPACE
              TEMPLATE_REPO_GITHUB_LOCATION=$GITHUB_WORKSPACE/../convoy-helm-template
              echo "$CHART_GITHUB_LOCATION"
              echo "$TEMPLATE_REPO_GITHUB_LOCATION"
              echo "TEMPLATE_REPO_GITHUB_LOCATION=$TEMPLATE_REPO_GITHUB_LOCATION"
              echo "Cloning convoy-helm-template"
              rm -rf $TEMPLATE_REPO_GITHUB_LOCATION
              template_version=$(yq --exit-status '.convoy-helm-template' Chart.yaml)
              if [ $? -eq 0 ]; then
                  echo "convoy-helm-template version: $template_version"
              else
                  echo "convoy-helm-template version not found.Exiting."
                  exit 1
              fi
              git clone --branch $template_version https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/${{github.repository_owner}}/convoy-helm-template.git $TEMPLATE_REPO_GITHUB_LOCATION
              echo "Copying the service values file"
              cp -r $CHART_GITHUB_LOCATION/services/* $TEMPLATE_REPO_GITHUB_LOCATION/helm-chart/values/apps/
              cp -r $CHART_GITHUB_LOCATION/Chart.yaml $TEMPLATE_REPO_GITHUB_LOCATION/helm-chart/Chart.yaml
              set -e
              cd $TEMPLATE_REPO_GITHUB_LOCATION/scripts
              ls -lrta ../helm-chart/values/apps/
              echo "Running package and push"
              ./package-and-push --no-push -n $CHART_NAME
              set +e
            fi
          }
          installGoDependencies() {
            go version
            go install golang.org/x/tools/cmd/goimports@latest
            which go
          }
          lintCheck() {
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
            flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
          }
          makeBuild() {
            set -e
            make service
            set +e
          }
          makeImage() {
            set -e
            make image
            set +e
          }
          modifiedDir() {
            set -e
            directories=$(echo ${{steps.changed-files-all.outputs.all_changed_and_modified_files}} | tr ' ' '\n' | awk -F'/' '{print $1}' | sort -u)
            directories=$(echo $directories | tr '\n' ' ')
            return "$directories"
            set +e
          }
          mvnwBuild() {
            set -e
            ./mvnw install -Dnative -DskipTests -Dquarkus.native.remote-container-build=true
            set +e
          }
          opsImageBuild() {
            set -e
            mvnwBuild
            dockerBuild "$1" "$2" "$3" "$4"
            set +e
          }
          pushproxBuild() {
            set -e
            installGoDependencies
            git config --global url."https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com".insteadOf "https://github.com"
            makeBuild
            makeImage
            ARTIFACT="$1"
            OS=$(echo "$ARTIFACT" | awk -F'[-]' '{print $3}')
            make os=$OS pushprox-client
            make clean
            ls -lrta client-package
            set +e
          }
          pythonLibraryBuild() {
            set -e
            ARTIFACT="$1"
            createPipConf
            if [ -f ./$ARTIFACT/requirements.txt ]; then python3 -m pip install -r ./$ARTIFACT/requirements.txt --dry-run --trusted-host ${{env.NEXUS_SERVER_ENDPOINT}}; fi
            lintCheck
            gradlewPythonwheel
          }
          qaBuild(){
            set -e
            createPipConf
            setupQAEnv
            export PYTHONPATH=lib
            export GITHUB_USER="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}"
            export GITHUB_TOKEN="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}"
            cp configs/qarel.json config.json
            source qavenv/bin/activate
            make clients -B
            source qavenv/bin/activate
            python3 ./main.py ./testcases -s -v --dry-run --run-long-tests --business-edition
            if [[ ${{steps.changed-files.outputs.any_modified}} == 'true' ]]; then
              IMAGE_NAME="$1"
              dockerBuild $IMAGE_NAME
            fi
            set +e
          }
          setupQAEnv() {
            INSTALL_DIR=/usr/local/bin
            sudo mkdir -p $INSTALL_DIR/openapitools
            curl https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/bin/utils/openapi-generator-cli.sh > openapi-generator-cli
            sudo cp openapi-generator-cli $INSTALL_DIR/openapitools/openapi-generator-cli
            sudo chmod 755 $INSTALL_DIR/openapitools/openapi-generator-cli
            sudo ln -f -s $INSTALL_DIR/openapitools/openapi-generator-cli $INSTALL_DIR/openapi-generator
            wget https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/6.0.0/openapi-generator-cli-6.0.0.jar -O openapi-generator-cli.jar
            sudo mv openapi-generator-cli.jar /usr/local/bin/openapi-generator-cli-6.0.0.jar
            python3 -m pip install --user virtualenv
            python3 -m pip install yq wheel
            python3 -m venv qavenv
            source qavenv/bin/activate
            python3 -m pip install -r scripts/requirements.txt --trusted-host ${{env.NEXUS_SERVER_ENDPOINT}}
            sudo python3 -m pip list | grep harness
            python3 -m pip list | grep harness              
          }
          tsmZipBuild() {
            set -e
            ARTIFACT="$1"
            mkdir -p build; cd tsmv101; terraform_build $PWD ../build/$ARTIFACT.zip; cd ../build; ls -l;
            unzip -l $ARTIFACT.zip
            cd ..
            set +e
          }
          terraformBuild(){
            set -e
            modifiedDir
            BASE_DIR=$PWD
            BUILD_DIR=$BASE_DIR/build
            mkdir -p $BUILD_DIR
            DIRECTORIES=$( modifiedDir )
            EXCLUDE_DIR=("build")
            for DIR in $DIRECTORIES
            do
              if [[ " ${EXCLUDE_DIR[*]} " != *"$DIR"* ]]; then 
                echo "building  ${DIR}"
                ARTIFACT_FILE=$BUILD_DIR/${DIR}.zip
                cd $BASE_DIR/$DIR
                VERSION=$(yq .version convoy.yaml)
                echo terraform_build $BASE_DIR/$DIR $ARTIFACT_FILE
                terraform_build $PWD $ARTIFACT_FILE
              fi
            done
            ls -lrta $BUILD_DIR
            set +e
          }
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            git config --global url."https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com".insteadOf "https://github.com"
            version=$(yq '.version' convoy.yaml)
            language=$(yq '.language' convoy.yaml)
            if [[ "$language" == "terraform" ]]; then
              terraformBuild
              return
            fi
            while IFS=$'\t' read -r name buildFunction ext file _; do
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "dockerFile: $file"
              $buildFunction "$name" "$ext" "$version" "$file"
            done < <(yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile] | @tsv" convoy.yaml)
          }
          set +e
          build "artifacts"
          build "dockerImages"
          build "helmCharts"
          build "terraform"

      - name: Cleanup
        if: always()
        run: |
          set +e
          sudo rm -rf target
          docker container prune --force
          docker volume prune --force

  build-arm:
    if: ${{ inputs.type == 'arm' }}
    runs-on: ARM64
    env:
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_LOCAL}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_LOCAL}}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Build
        shell: bash
        run: |
          dockerBuild() {
            set -e
            IMAGE_NAME="$1"
            FILE="$4"
            if [[ "$FILE" == "null" || -z "$FILE" ]]; then
              FILE="./Dockerfile"
            fi
            echo "$FILE"
            docker build -f $FILE -t $IMAGE_NAME .
            set +e
          }
          jarBuild() {
            set -e
            ./mvnw package -Dnative -DskipTests -Dquarkus.native.remote-container-build=true
            set +e
          }
          mvnwBuild() {
            set -e
            ./mvnw install -Dnative -DskipTests -Dquarkus.native.remote-container-build=true
            set +e
          }
          opsImageBuild() {
            set -e
            mvnwBuild
            dockerBuild "$1" "$2" "$3" "$4"
            set +e
          }
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            version=$(yq '.version' convoy.yaml)
            while IFS=$'\t' read -r name buildFunction ext file _; do
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "dockerFile: $file"
              $buildFunction "$name" "$ext" "$version" "$file"
            done < <(yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile] | @tsv" convoy.yaml)
          }
          set +e
          build "artifacts"
          build "dockerImages"

      - name: Cleanup
        if: always()
        run: |
          set +e
          sudo rm -rf target
          docker container prune --force
          docker volume prune --force
          