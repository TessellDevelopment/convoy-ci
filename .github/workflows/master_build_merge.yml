---
name: Tessell Pipelines Code Build Post merge
on:
  workflow_call:
    inputs:
      type:
        description: 'This is used to determine build type'
        required: true
        type: string
      tag:
        description: 'Latest tag for upload'
        required: true
        type: string
      label:
        description: 'Release label for upload'
        required: true
        type: string
      dev_build:
        description: 'Determine whether dispatch is on dev branch or not'
        required: false
        default: false
        type: boolean  

    outputs:
      ARTIFACT_CHECKSUMS:
        description: 'Consolidated Checksum of generated artifacts'
        value: ${{ (jobs.build-ui.outputs.ARTIFACT_CHECKSUMS) || (jobs.build-amd.outputs.ARTIFACT_CHECKSUMS) || (jobs.build-ubuntu-latest.outputs.ARTIFACT_CHECKSUMS) || (jobs.build-arm.outputs.ARTIFACT_CHECKSUMS) }} 
      BRANCH_COVERAGE:
        description: 'Branch coverage parameters of the repository'
        value: ${{ (jobs.build-ui.outputs.BRANCH_COVERAGE) || (jobs.build-amd.outputs.BRANCH_COVERAGE) || (jobs.build-ubuntu-latest.outputs.BRANCH_COVERAGE) || (jobs.build-arm.outputs.BRANCH_COVERAGE) }} 
      IS_CONTENT_FOR_GITHUB_OUTPUT_POPULATED:
        description: Bool flag to determine whether github output is populated with CONTENT_FOR_GITHUB_OUTPUT
        value: ${{ (jobs.build-amd.outputs.IS_CONTENT_FOR_GITHUB_OUTPUT_POPULATED) }}
      STATEMENT_COVERAGE:
        description: 'Statement coverage parameters of the repository'
        value: ${{ (jobs.build-ui.outputs.STATEMENT_COVERAGE) || (jobs.build-amd.outputs.STATEMENT_COVERAGE) || (jobs.build-ubuntu-latest.outputs.STATEMENT_COVERAGE) || (jobs.build-arm.outputs.STATEMENT_COVERAGE) }} 
jobs:

  build-ui:
    if: ${{ inputs.type == 'ui-build' }}
    runs-on: ui-build
    outputs:
      ARTIFACT_CHECKSUMS: ${{ steps.build.outputs.ARTIFACT_CHECKSUMS }}
      BRANCH_COVERAGE: ${{ steps.build.outputs.BRANCH_COVERAGE }}
      STATEMENT_COVERAGE: ${{ steps.build.outputs.STATEMENT_COVERAGE }}
    env:
      ARTIFACTS_DEV_ACCESS_KEY: ${{ secrets.ARTIFACTS_DEV_ACCESS_KEY }}
      ARTIFACTS_DEV_SECRET_KEY: ${{ secrets.ARTIFACTS_DEV_SECRET_KEY }}
      ARTIFACTS_DEV_S3: ${{vars.ARTIFACTS_DEV_S3}}
      ARTIFACTS_UPLOAD_ACCESS_KEY: ${{ secrets.ARTIFACTS_UPLOAD_ACCESS_KEY }}
      ARTIFACTS_UPLOAD_SECRET_KEY: ${{ secrets.ARTIFACTS_UPLOAD_SECRET_KEY }}
      AWS_ACCOUNT_TESSELL_DEV: ${{vars.AWS_ACCOUNT_TESSELL_DEV}}
      AWS_ACCOUNT_TESSELL_QA: ${{vars.AWS_ACCOUNT_TESSELL_QA}}
      AWS_ACCOUNT_TESSELL_STAGE: ${{vars.AWS_ACCOUNT_TESSELL_STAGE}}
      AWS_ACCOUNT_TESSELL_PROD: ${{vars.AWS_ACCOUNT_TESSELL_PROD}}
      BASE_BRANCH: "${{github.event.pull_request.base.ref}}"
      CI_BRANCH: TDEVOPS-3633_convoy_ci_on_3693_test
      CODE_COVERAGE_S3: ${{vars.CODE_COVERAGE_S3}}
      CONVOY_API_KEY: ${{secrets.CONVOY_AUTH_TOKEN}}
      DEV_BUILD: ${{inputs.dev_build}}
      DEVQA_INFRA_ACCESS_KEY: ${{ secrets.DEVQA_INFRA_ACCESS_KEY }}
      DEVQA_INFRA_SECRET_KEY: ${{ secrets.DEVQA_INFRA_SECRET_KEY }}
      DOCKERHUB_ORG: ${{vars.DOCKERHUB_ORG}}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      IMAGE_SCAN_API_URL: http://${{vars.CONVOY_DEV_API_ENDPOINT}}/devops/code/vulnerabilities/validate
      LABEL: ${{inputs.label}}
      LATEST_TAG: ${{inputs.tag}}
      NEXUS_ARTIFACT_REPO: ${{vars.NEXUS_REPO_TESSELL_ARTIFACTS}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_PUBLIC}}
      NEXUS_PULL_REPOS_M2: tessell-m2-component
      NEXUS_PUSH_REPOS_M2: ${{vars.NEXUS_PUSH_REPOS_M2}}
      NEXUS_PUSH_REPOS_NPM: ${{vars.NEXUS_PUSH_REPOS_NPM}}
      NEXUS_PULL_REPOS_PY: tessell-py-component
      NEXUS_PUSH_REPOS_PY: tessell-repos-py-component
      NEXUS_REPO_TESSELLOPS_ARTIFACTS: ${{vars.NEXUS_REPO_TESSELLOPS_ARTIFACTS}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_PUBLIC}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      PROD_ASSET_ACCESS_KEY: ${{ secrets.PROD_ASSET_ACCESS_KEY }}
      PROD_ASSET_SECRET_KEY: ${{ secrets.PROD_ASSET_SECRET_KEY }}
      REPO: "${{github.event.pull_request.base.repo.name}}"
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      TESSELL_ARTIFACTS_DEV_S3: ${{vars.TESSELL_ARTIFACTS_DEV_S3}}
      TESSELL_ARTIFACTS_QA_S3: ${{vars.TESSELL_ARTIFACTS_QA_S3}}
      TESSELL_ARTIFACTS_STAGE_S3: ${{vars.TESSELL_ARTIFACTS_STAGE_S3}}
      TESSELL_ARTIFACTS_PROD_S3: ${{vars.TESSELL_ARTIFACTS_PROD_S3}}
      TESSELL_ARTIFACTS_PROD_ASSETS_S3: ${{vars.TESSELL_ARTIFACTS_PROD_ASSETS_S3}}
      TESSELL_GCP_APP_NAME: ${{ vars.TESSELL_GCP_APP_NAME }}
      TESSELL_GCP_ARTIFACTS_BUCKET: ${{ vars.TESSELL_GCP_ARTIFACTS_BUCKET }}
      TESSELL_GCP_DOCKERHUB_ORG: ${{vars.TESSELL_GCP_DOCKERHUB_ORG}}
      TESSELL_GCP_PROJECT_ID: ${{vars.TESSELL_GCP_PROJECT_ID}}
      TESSELL_GCP_REGION: ${{vars.TESSELL_GCP_REGION}}
      TESSELL_GCP_SERVICE_ACCOUNT_NAME: ${{vars.TESSELL_GCP_SERVICE_ACCOUNT_NAME}}
      TESSELL_UI_ENV_SECRET: ${{secrets.TESSELL_UI_ENV_SECRET}}
    steps:
      - name: Set Repositories for Dev Build
        if: ${{ inputs.dev_build }}
        run: |
          echo "DOCKERHUB_ORG=tesselldev" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_M2=tessell-repos-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_NPM=tessell-repos-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_PY=tessell-repos-py-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_M2=tessell-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_NPM=tessell-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_PY=tessell-py-development" >> $GITHUB_ENV
          echo "TESSELL_ARTIFACTS_PROD_ASSETS_S3=tesselltools-dev" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0
      
      - name: Setup CI Scripts
        run: |
          cd ~/convoy-ci
          git checkout main
          git pull
          git checkout ${{env.CI_BRANCH}}
          git pull
          cd ~-
          cp -r ~/convoy-ci/.github/ci-scripts ./ci-scripts

      - name: Set Application Name
        run: |
          export APP_GROUP=$(yq '.appGroup // "tessell"' convoy.yaml)
          echo "APP_GROUP=$APP_GROUP" >> $GITHUB_ENV
          if [[ ${APP_GROUP} == ${TESSELL_GCP_APP_NAME} ]]; then
            export DOCKERHUB_ORG=$TESSELL_GCP_REGION-docker.pkg.dev/$TESSELL_GCP_PROJECT_ID/$TESSELL_GCP_DOCKERHUB_ORG
            echo "DOCKERHUB_ORG=$DOCKERHUB_ORG" >> $GITHUB_ENV
          fi

      - name: Login to docker
        uses: docker/login-action@v3.0.0
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Login gcloud
        id: auth
        if: ${{ env.APP_GROUP == env.TESSELL_GCP_APP_NAME }}
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.TESSELL_GCP_SERVICE_ACCOUNT_KEY_JSON }}'
          token_format: access_token
          create_credentials_file: true

      - name: Login to Artifact Registry
        if: ${{ env.APP_GROUP == env.TESSELL_GCP_APP_NAME }}
        uses: docker/login-action@v1
        with:
          registry: ${{vars.TESSELL_GCP_REGION}}-docker.pkg.dev 
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Build
        id: build
        shell: bash
        run: |
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            version=$(yq '.version' convoy.yaml)
            environments=("dev" "qa" "stage" "prod")
            yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile] | @csv" convoy.yaml | sed 's/,/ /g' > artifacts.txt
            lineNumber=1
            while :; do
              echo ------------------------------
              artifactData=$(sed "$lineNumber!d" artifacts.txt)
              if [[ -z "$artifactData" ]]; then
                break
              fi
              read -r name buildFunction ext file <<< "$artifactData"
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "Version: $version"
              echo "dockerFile: $file"
              "${buildFunction}AndPush" $name $ext $version $file 
              echo "$type $name done"
              echo ------------------------------
              lineNumber=$((lineNumber+1))
            done
            rm artifacts.txt
          }
          set +e
          source ./ci-scripts/bash/functions-for-build
          ARTIFACT_CHECKSUMS=""
          BRANCH_COVERAGE=""
          STATEMENT_COVERAGE=""
          build "artifacts"
          build "dockerImages"
          build "helmCharts"
          parseAndPushCoverageReport
          echo "ARTIFACT_CHECKSUMS=$ARTIFACT_CHECKSUMS" >> $GITHUB_OUTPUT
          echo "BRANCH_COVERAGE=$BRANCH_COVERAGE" >> $GITHUB_OUTPUT
          echo "STATEMENT_COVERAGE=$STATEMENT_COVERAGE" >> $GITHUB_OUTPUT


      # - name: Slack Notification
      #   uses: act10ns/slack@v2.0.0
      #   if: failure()
      #   with:
      #     status: ${{ job.status }}
      #     steps: ${{ toJson(steps) }}
      #     channel: ${{ secrets.SLACK_DEVOPS_CHANNEL }}
    
  build-ubuntu-latest:
    if: ${{ inputs.type == 'ubuntu-latest' }}
    runs-on: ubuntu-latest
    outputs:
      ARTIFACT_CHECKSUMS: ${{ steps.build.outputs.ARTIFACT_CHECKSUMS }}
      BRANCH_COVERAGE: ${{ steps.build.outputs.BRANCH_COVERAGE }}
      STATEMENT_COVERAGE: ${{ steps.build.outputs.STATEMENT_COVERAGE }}
    env:
      ARTIFACTS_DEV_ACCESS_KEY: ${{ secrets.ARTIFACTS_DEV_ACCESS_KEY }}
      ARTIFACTS_DEV_SECRET_KEY: ${{ secrets.ARTIFACTS_DEV_SECRET_KEY }}
      ARTIFACTS_UPLOAD_ACCESS_KEY: ${{ secrets.ARTIFACTS_UPLOAD_ACCESS_KEY }}
      ARTIFACTS_UPLOAD_SECRET_KEY: ${{ secrets.ARTIFACTS_UPLOAD_SECRET_KEY }}
      AWS_ACCOUNT_CODE_COVERAGE: ${{vars.AWS_ACCOUNT_CODE_COVERAGE}}
      AWS_ACCOUNT_TESSELL_DEV: ${{vars.AWS_ACCOUNT_TESSELL_DEV}}
      AWS_ACCOUNT_TESSELL_QA: ${{vars.AWS_ACCOUNT_TESSELL_QA}}
      AWS_ACCOUNT_TESSELL_STAGE: ${{vars.AWS_ACCOUNT_TESSELL_STAGE}}
      AWS_ACCOUNT_TESSELL_PROD: ${{vars.AWS_ACCOUNT_TESSELL_PROD}}
      AWS_EC2_METADATA_DISABLED: true
      BASE_BRANCH: "${{github.event.pull_request.base.ref}}"
      CI_BRANCH: TDEVOPS-3633_convoy_ci_on_3693_test
      CODE_COVERAGE_S3: ${{vars.CODE_COVERAGE_S3}}
      CONVOY_API_KEY: ${{secrets.CONVOY_AUTH_TOKEN}}
      CONVOY_MINIO_ACCESS_KEY: ${{secrets.CONVOY_MINIO_ACCESS_KEY}}
      CONVOY_MINIO_ENDPOINT: https://minio.convoy.tessell.cloud
      CONVOY_MINIO_SECRET_KEY: ${{secrets.CONVOY_MINIO_SECRET_KEY}}
      DEV_BUILD: ${{inputs.dev_build}}
      DEVQA_INFRA_ACCESS_KEY: ${{ secrets.DEVQA_INFRA_ACCESS_KEY }}
      DEVQA_INFRA_SECRET_KEY: ${{ secrets.DEVQA_INFRA_SECRET_KEY }}
      DOCKERHUB_ORG: ${{vars.DOCKERHUB_ORG}}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      GOPATH: /home/runner/go
      IMAGE_SCAN_API_URL: http://${{vars.CONVOY_DEV_API_ENDPOINT}}/devops/code/vulnerabilities/validate
      LABEL: ${{inputs.label}}
      LATEST_TAG: ${{inputs.tag}}
      NEXUS_ARTIFACT_REPO: ${{vars.NEXUS_REPO_TESSELL_ARTIFACTS}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_PUBLIC}}
      NEXUS_PULL_REPOS_M2: tessell-m2-development
      NEXUS_PULL_REPOS_PY: tessell-py-development
      NEXUS_PUSH_REPOS_M2: ${{ vars.NEXUS_PUSH_REPOS_M2 }}
      NEXUS_PUSH_REPOS_PY: ${{ vars.NEXUS_PUSH_REPOS_PY }}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_PUBLIC}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      PROD_ASSET_ACCESS_KEY: ${{ secrets.PROD_ASSET_ACCESS_KEY }}
      PROD_ASSET_SECRET_KEY: ${{ secrets.PROD_ASSET_SECRET_KEY }}
      REPO: "${{github.event.pull_request.base.repo.name}}"
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      TESSELL_ARTIFACTS_DEV_S3: ${{vars.TESSELL_ARTIFACTS_DEV_S3}}
      TESSELL_ARTIFACTS_QA_S3: ${{vars.TESSELL_ARTIFACTS_QA_S3}}
      TESSELL_ARTIFACTS_STAGE_S3: ${{vars.TESSELL_ARTIFACTS_STAGE_S3}}
      TESSELL_ARTIFACTS_PROD_S3: ${{vars.TESSELL_ARTIFACTS_PROD_S3}}
      TESSELL_ARTIFACTS_PROD_ASSETS_S3: ${{vars.TESSELL_ARTIFACTS_PROD_ASSETS_S3}}
    steps:
      - name: Set Repositories for Dev Build
        if: ${{ inputs.dev_build }}
        run: |
          echo "DOCKERHUB_ORG=tesselldev" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_M2=tessell-repos-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_NPM=tessell-repos-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_PY=tessell-repos-py-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_M2=tessell-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_NPM=tessell-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_PY=tessell-py-development" >> $GITHUB_ENV
          echo "TESSELL_ARTIFACTS_PROD_ASSETS_S3=tesselltools-dev" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5.0.0
        with:
          python-version: 3.9

      - name: Setup Go
        uses: actions/setup-go@v2

      - name: Set up JDK 17
        uses: actions/setup-java@v4.0.0
        with:
          java-version: '17'
          distribution: 'adopt'

      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v3.0.0

      - name: Login to docker
        uses: docker/login-action@v3.0.0
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Setup CI Scripts
        run: |
          git clone https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/TessellDevelopment/convoy-ci.git
          cd convoy-ci
          git checkout ${{env.CI_BRANCH}}
          git pull
          cd ..
          cp -r ./convoy-ci/.github/ci-scripts ./ci-scripts

      - name: Create pip conf
        run: |
          createPipConf() {
            echo "[global]" > pip.conf
            echo "index =  ${{env.NEXUS_PROTOCOL}}://${{ secrets.CIPIPELINE_NEXUS_USERNAME }}:${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}@${{ env.NEXUS_SERVER_ENDPOINT }}/repository/${{ env.NEXUS_PULL_REPOS_PY }}/simple" >> pip.conf
            echo "index-url = ${{env.NEXUS_PROTOCOL}}://${{ secrets.CIPIPELINE_NEXUS_USERNAME }}:${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}@${{ env.NEXUS_SERVER_ENDPOINT }}/repository/${{ env.NEXUS_PULL_REPOS_PY }}/simple" >> pip.conf
            echo "extra-index-url = https://pypi.org/simple" >> pip.conf
            sudo cp pip.conf /etc/pip.conf
            cat /etc/pip.conf
          }
          createPipConf
        shell: bash

      - name: Install dependencies
        run: |
          installAwsCli() {
            curl -L -o install-aws.sh https://raw.githubusercontent.com/unfor19/install-aws-cli-action/master/entrypoint.sh
            chmod +x install-aws.sh
            sudo ./install-aws.sh "v2" "amd64"
            rm install-aws.sh
          }
          source ./ci-scripts/bash/functions-for-build
          installPythonDependencies
          installAwsCli
          installMinioClient
      
      - name: Build
        id: build
        shell: bash
        run: |
          artifactCopyAndPush() {
            set -e
            ARTIFACT="$1"
            EXT="$2"
            FILE_PATH="$5"
            requiredInputs="1 2 5"
            validateInputs "$requiredInputs" "$@" 
            awsConfigureTessellArtifacts
            pushToNexus "$FILE_PATH" "${{env.NEXUS_ARTIFACT_REPO}}/${{env.LABEL}}/$ARTIFACT/$ARTIFACT-${LATEST_TAG}.$EXT"
            aws s3 cp $FILE_PATH "s3://${{vars.ARTIFACTS_DEV_S3}}/${LABEL}/$ARTIFACT/$ARTIFACT-${LATEST_TAG}.$EXT"
            set +e
          }
          awsConfigureTessellArtifacts() {
            aws configure set aws_access_key_id ${{ secrets.ARTIFACTS_DEV_ACCESS_KEY }}
            aws configure set aws_secret_access_key ${{ secrets.ARTIFACTS_DEV_SECRET_KEY }}
            aws configure set region ap-south-1
          }
          dockerCopyAndPush() {
            set -e
            IMAGE="$1"
            BASE_IMAGE="$6"
            requiredInputs="1 6"
            validateInputs "$requiredInputs" "$@" 
            docker tag $BASE_IMAGE:latest ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG}
            docker push ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG}
            set +e
          }
          elasticConf() {
            git config --global url."https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com".insteadOf "https://github.com"
            installGoDependencies
            git clone https://github.com/magefile/mage
            cd mage
            go run bootstrap.go
            cd ..
          }
          elasticBuildAndPush() {
            set -e
            IMAGE="$1"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            elasticConf
            echo "----------------------------------------------"
            echo "----------- Building Service -----------------"
            export GOPATH=/home/runner/go/bin
            export PATH=/go/bin:/usr/local/go/bin:/opt/maven/bin:/usr/lib/jvm/java-17-openjdk-amd64/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/runner/go/bin
            cd filebeat
            mage package
            cp ./build/golang-crossbuild/filebeat-linux-amd64 ./filebeat
            echo "----------------------------------------------"
            echo "------------ Building Image ------------------"
            docker build -t ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG} .
            docker push ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG}
            cd ..
            elasticTarBuild
            FILE_PATH_LINUX="./filebeat/build/distributions/filebeat-linux.tar.gz"
            FILE_PATH_WINDOWS="./filebeat/build/distributions/filebeat-windows.tar.gz"
            mvnDeploy "filebeat-linux" "tar.gz" $FILE_PATH_LINUX "tessell.filebeat" "${LATEST_TAG}"
            mvnDeploy "filebeat-windows" "tar.gz" $FILE_PATH_WINDOWS "tessell.filebeat" "${LATEST_TAG}"
            awsConfigureProdAssets
            EXTENSION="tar.gz"
            ARTIFACT="filebeat-linux"
            push_release_manifest_artifacts "filebeat-linux.tar.gz" "$FILE_PATH_LINUX"
            ARTIFACT="filebeat-windows"
            push_release_manifest_artifacts "filebeat-windows.tar.gz" "$FILE_PATH_WINDOWS"
            set +e
          }
          elasticTarBuild() {
            echo "----------------------------------------------"
            echo "---------- Creating Tar Files -----------------"
            PACKAGES_DIR=./filebeat/build/distributions/
            mkdir -p $PACKAGES_DIR
            cp ./filebeat/tessell-filebeat-linux.yml $PACKAGES_DIR/filebeat.yml
            cp ./filebeat/build/golang-crossbuild/filebeat-linux-amd64 $PACKAGES_DIR/filebeat
            cp ./filebeat/filebeat.service $PACKAGES_DIR/filebeat.service
            pushd $PACKAGES_DIR
            tar -zcvf filebeat-linux.tar.gz filebeat.yml filebeat filebeat.service
            popd
            cp ./filebeat/tessell-filebeat-windows.yml $PACKAGES_DIR/filebeat.yml
            cp ./filebeat/build/golang-crossbuild/filebeat-windows-amd64.exe $PACKAGES_DIR/filebeat.exe 
            pushd $PACKAGES_DIR
            tar -zcvf filebeat-windows.tar.gz filebeat.yml filebeat.exe
            popd
          }
          infraProvisionBuildAndPush() {
            set -e
            lintCheck
            mkdir -p build/tools
            wget https://repo1.maven.org/maven2/org/openapitools/openapi-generator-cli/6.0.0/openapi-generator-cli-6.0.0.jar -O build/tools/openapi-generator-cli-6.0.0.jar
            IMAGE="$1"
            gradlewDockerTag
            docker push ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG}
            set +e
          }
          lintCheck() {
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
            flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
          }
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            mkdir -p $HOME/.m2
            cp .github/scripts/settings.xml $HOME/.m2/settings.xml
            cat $HOME/.m2/settings.xml
            version=$(yq '.version' convoy.yaml)
            environments=("dev" "qa" "stage" "prod")
            yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile, .filePath, .baseImage] | @csv" convoy.yaml | sed 's/,/ /g' > artifacts.txt
            lineNumber=1
            while :; do
              echo ------------------------------
              artifactData=$(sed "$lineNumber!d" artifacts.txt)
              if [[ -z "$artifactData" ]]; then
                break
              fi
              read -r name buildFunction ext file <<< "$artifactData"
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "Version: $version"
              echo "dockerFile: $file"
              echo "filePath: $filePath"
              echo "baseImage: $baseImage"
              "${buildFunction}AndPush" $name $ext $version $file 
              echo "Artifact $name done"
              echo ------------------------------
              lineNumber=$((lineNumber+1))
            done
            rm artifacts.txt
          }
          set +e
          source ./ci-scripts/bash/functions-for-build
          ARTIFACT_CHECKSUMS=""
          BRANCH_COVERAGE=""
          STATEMENT_COVERAGE=""
          build "artifacts"
          build "dockerImages"
          build "helmCharts"
          parseAndPushCoverageReport
          echo "ARTIFACT_CHECKSUMS=$ARTIFACT_CHECKSUMS" >> $GITHUB_OUTPUT
          echo "BRANCH_COVERAGE=$BRANCH_COVERAGE" >> $GITHUB_OUTPUT
          echo "STATEMENT_COVERAGE=$STATEMENT_COVERAGE" >> $GITHUB_OUTPUT


      # - name: Slack Notification
      #   uses: act10ns/slack@v2.0.0
      #   if: failure()
      #   with:
      #     status: ${{ job.status }}
      #     steps: ${{ toJson(steps) }}
      #     channel: ${{ secrets.SLACK_DEVOPS_CHANNEL }}

  build-amd:
    if: ${{ inputs.type == 'amd' }}
    runs-on: self-hosted
    outputs:
      ARTIFACT_CHECKSUMS: ${{ steps.build.outputs.ARTIFACT_CHECKSUMS }}
      BRANCH_COVERAGE: ${{ steps.build.outputs.BRANCH_COVERAGE }}
      IS_CONTENT_FOR_GITHUB_OUTPUT_POPULATED: ${{ steps.build.outputs.IS_CONTENT_FOR_GITHUB_OUTPUT_POPULATED }}
      STATEMENT_COVERAGE: ${{ steps.build.outputs.STATEMENT_COVERAGE }}
    env:
      ARTIFACTS_DEV_ACCESS_KEY: ${{ secrets.ARTIFACTS_DEV_ACCESS_KEY }}
      ARTIFACTS_DEV_SECRET_KEY: ${{ secrets.ARTIFACTS_DEV_SECRET_KEY }}
      ARTIFACTS_DEV_S3: ${{vars.ARTIFACTS_DEV_S3}}
      ARTIFACTS_UPLOAD_ACCESS_KEY: ${{ secrets.ARTIFACTS_UPLOAD_ACCESS_KEY }}
      ARTIFACTS_UPLOAD_SECRET_KEY: ${{ secrets.ARTIFACTS_UPLOAD_SECRET_KEY }}
      AWS_ACCOUNT_CODE_COVERAGE: ${{vars.AWS_ACCOUNT_CODE_COVERAGE}}
      AWS_ACCOUNT_TESSELL_COMMON_INFRA: ${{vars.AWS_ACCOUNT_TESSELL_COMMON_INFRA}}
      AWS_ACCOUNT_TESSELL_DEV: ${{vars.AWS_ACCOUNT_TESSELL_DEV}}
      AWS_ACCOUNT_TESSELL_QA: ${{vars.AWS_ACCOUNT_TESSELL_QA}}
      AWS_ACCOUNT_TESSELL_STAGE: ${{vars.AWS_ACCOUNT_TESSELL_STAGE}}
      AWS_ACCOUNT_TESSELL_PROD: ${{vars.AWS_ACCOUNT_TESSELL_PROD}}
      BASE_BRANCH: "${{github.event.pull_request.base.ref}}"
      BRANCH_NAME: ${{ github.event.pull_request.head.ref }}
      CI_BRANCH: TDEVOPS-3633_convoy_ci_on_3693_test
      CI_PHASE: postMerge
      CODE_COVERAGE_S3: ${{vars.CODE_COVERAGE_S3}}
      CONTENT_FOR_GITHUB_OUTPUT: /tmp/content-for-github-output
      CONVOY_API_KEY: ${{secrets.CONVOY_AUTH_TOKEN}}
      DISPATCH_BRANCH_NAME: ${{ github.ref_name }}
      DEV_BUILD: ${{inputs.dev_build}}
      DEVOPS_GIT_METADATA_API_ENDPOINT: http://${{vars.CONVOY_DEV_API_ENDPOINT}}/devops/git-metadata
      DEVQA_INFRA_ACCESS_KEY: ${{ secrets.DEVQA_INFRA_ACCESS_KEY }}
      DEVQA_INFRA_SECRET_KEY: ${{ secrets.DEVQA_INFRA_SECRET_KEY }}
      DOCKERHUB_ORG: ${{vars.DOCKERHUB_ORG}}
      GIT_BASE_REF: ${{ github.event.pull_request.base.sha }}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      GH_API_URL: ${{vars.GH_API_URL}}
      GOPATH: /home/github/go
      IMAGE_SCAN_API_URL: http://${{vars.CONVOY_DEV_API_ENDPOINT}}/devops/code/vulnerabilities/validate
      LABEL: ${{inputs.label}}
      LATEST_TAG: ${{inputs.tag}}
      MC_ALIAS_FOR_CONVOY_MINIO: minio_ci
      NAMESPACE: "convoy"
      NEXUS_ADDR: http://nexus.nexus.svc.cluster.local
      NEXUS_ARTIFACT_REPO: ${{vars.NEXUS_REPO_TESSELL_ARTIFACTS}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_LOCAL}}
      NEXUS_PULL_REPOS_M2: tessell-m2-development
      NEXUS_PULL_REPOS_PY: tessell-py-development
      NEXUS_PUSH_REPOS_M2: ${{ vars.NEXUS_PUSH_REPOS_M2 }}
      NEXUS_PUSH_REPOS_PY: ${{ vars.NEXUS_PUSH_REPOS_PY }}
      NEXUS_REPO_TESSELLOPS_ARTIFACTS: ${{vars.NEXUS_REPO_TESSELLOPS_ARTIFACTS}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_LOCAL}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      PACKER_AWS_ACCESS_KEY_ID: ${{ secrets.PACKER_AWS_ACCESS_KEY_ID }}
      PACKER_AWS_SECRET_ACCESS_KEY: ${{ secrets.PACKER_AWS_SECRET_ACCESS_KEY }}
      PACKER_AZURE_CLIENT_ID: ${{ secrets.PACKER_AZURE_CLIENT_ID }}
      PACKER_AZURE_CLIENT_SECRET: ${{ secrets.PACKER_AZURE_CLIENT_SECRET }}
      PACKER_AZURE_TENANT_ID: ${{ secrets.PACKER_AZURE_TENANT_ID }}
      PACKER_AZURE_SUBSCRIPTION_ID: ${{ secrets.PACKER_AZURE_SUBSCRIPTION_ID }}
      PROD_ASSET_ACCESS_KEY: ${{ secrets.PROD_ASSET_ACCESS_KEY }}
      PROD_ASSET_SECRET_KEY: ${{ secrets.PROD_ASSET_SECRET_KEY }}
      PR_NUMBER: ${{ github.event.pull_request.number }}
      RELEASE_MANIFEST_URL: http://${{vars.CONVOY_DEV_API_ENDPOINT}}/devops/applications/app-groups/tessell/release-manifests
      RELEASE_PATH: ${{inputs.label}}
      REPO: "${{github.event.pull_request.base.repo.name}}"
      REPOSITORY: "${{github.repository}}"
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      TESSELL_ARTIFACTS_DEV_S3: ${{vars.TESSELL_ARTIFACTS_DEV_S3}}
      TESSELL_ARTIFACTS_QA_S3: ${{vars.TESSELL_ARTIFACTS_QA_S3}}
      TESSELL_ARTIFACTS_STAGE_S3: ${{vars.TESSELL_ARTIFACTS_STAGE_S3}}
      TESSELL_ARTIFACTS_PROD_S3: ${{vars.TESSELL_ARTIFACTS_PROD_S3}}
      TESSELL_ARTIFACTS_PROD_ASSETS_S3: ${{vars.TESSELL_ARTIFACTS_PROD_ASSETS_S3}}
      TESSELL_ARTIFACTS_TF_DEV_S3: ${{vars.TESSELL_ARTIFACTS_TF_DEV_S3}}
      TESSELL_ARTIFACTS_TF_QA_S3: ${{vars.TESSELL_ARTIFACTS_TF_QA_S3}}
      TESSELL_ARTIFACTS_TF_STAGE_S3: ${{vars.TESSELL_ARTIFACTS_TF_STAGE_S3}}
      TESSELL_ARTIFACTS_TF_PROD_S3: ${{vars.TESSELL_ARTIFACTS_TF_PROD_S3}}
      TESSELL_GCP_APP_NAME: ${{ vars.TESSELL_GCP_APP_NAME }}
      TESSELL_GCP_ARTIFACTS_BUCKET: ${{ vars.TESSELL_GCP_ARTIFACTS_BUCKET }}
      TESSELL_GCP_DOCKERHUB_ORG: ${{vars.TESSELL_GCP_DOCKERHUB_ORG}}
      TESSELL_GCP_PROJECT_ID: ${{vars.TESSELL_GCP_PROJECT_ID}}
      TESSELL_GCP_REGION: ${{vars.TESSELL_GCP_REGION}}
      TESSELL_GCP_SERVICE_ACCOUNT_NAME: ${{vars.TESSELL_GCP_SERVICE_ACCOUNT_NAME}}
      TS_API_KEY: ${{ secrets.TS_API_KEY }}
      TS_TAILNET: ${{ secrets.TS_TAILNET }}
    steps:
      - name: Set Repositories for Dev Build
        if: ${{ inputs.dev_build }}
        run: |
          echo "DOCKERHUB_ORG=tesselldev" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_M2=tessell-repos-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_NPM=tessell-repos-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_PY=tessell-repos-py-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_M2=tessell-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_NPM=tessell-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_PY=tessell-py-development" >> $GITHUB_ENV
          echo "TESSELL_ARTIFACTS_PROD_ASSETS_S3=tesselltools-dev" >> $GITHUB_ENV
          echo "GITHUB_REPO_NAME=${GITHUB_REPOSITORY#$GITHUB_REPOSITORY_OWNER/}" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Setup CI Scripts
        run: |
          cd ~/convoy-ci
          git checkout main
          git pull
          git checkout ${{env.CI_BRANCH}}
          git pull
          cd ~-
          cp -r ~/convoy-ci/.github/ci-scripts ./ci-scripts

      - name: Set Application Name
        run: |
          export APP_GROUP=$(yq '.appGroup // "tessell"' convoy.yaml)
          echo "APP_GROUP=$APP_GROUP" >> $GITHUB_ENV
          if [[ ${APP_GROUP} == ${TESSELL_GCP_APP_NAME} ]]; then
            export DOCKERHUB_ORG=$TESSELL_GCP_REGION-docker.pkg.dev/$TESSELL_GCP_PROJECT_ID/$TESSELL_GCP_DOCKERHUB_ORG
            echo "DOCKERHUB_ORG=$DOCKERHUB_ORG" >> $GITHUB_ENV
          fi

      # - name: Check specific file changes
      #   id: changed-files
      #   uses: tj-actions/changed-files@v42.0.2
      #   with:
      #     files: |
      #       Chart.yaml
      #       services/**
      #       scripts/Dockerfile
      #       scripts/initializeAutomation.sh

      - name: Check All file changes
        id: changed-files-all
        uses: step-security/changed-files@v45.0.1
      

      - name: Login to docker
        uses: docker/login-action@v3.0.0
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Login gcloud
        id: auth
        if: ${{ env.APP_GROUP == env.TESSELL_GCP_APP_NAME }}
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.TESSELL_GCP_SERVICE_ACCOUNT_KEY_JSON }}'
          token_format: access_token
          create_credentials_file: true

      - name: Login to Artifact Registry
        if: ${{ env.APP_GROUP == env.TESSELL_GCP_APP_NAME }}
        uses: docker/login-action@v1
        with:
          registry: ${{vars.TESSELL_GCP_REGION}}-docker.pkg.dev 
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Build and Push
        id: build
        shell: bash
        env:
          # CHANGED_FILES_ANY_MODIFIED: ${{steps.changed-files.outputs.any_modified}}
          CHANGED_AND_MODIFIED_FILES: ${{steps.changed-files-all.outputs.all_changed_and_modified_files}}
        run: |
          agentBuild() {
            set -e
            installGoDependencies
            ARTIFACT="$1"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            OS=$(echo "$ARTIFACT" | awk -F'[-]' '{print $4}')
            SERVICE=$(echo "$ARTIFACT" | awk -F'[-]' '{print $2}')
            make os=$OS nexus_protocol=${{env.NEXUS_PROTOCOL}} nexus_server_endpoint=${{env.NEXUS_SERVER_ENDPOINT}} $SERVICE
            set +e
          }
          agentBuildAndPush() {
            agentBuild "$@"
            set -e
            EXTENSION="$2"
            mvnDeploy "$ARTIFACT" "$EXTENSION" "package/$ARTIFACT.$EXTENSION" "tessell.agent" "${LATEST_TAG}"
            awsConfigureProdAssets
            push_release_manifest_artifacts "$ARTIFACT.$EXTENSION" "package/$ARTIFACT.$EXTENSION"
            set +e
          }
          awsConfigureTessellArtifacts() {
            aws configure set aws_access_key_id ${{ secrets.ARTIFACTS_DEV_ACCESS_KEY }}
            aws configure set aws_secret_access_key ${{ secrets.ARTIFACTS_DEV_SECRET_KEY }}
            aws configure set region ap-south-1
          }
          cloneHelmTemplate() {
            GITHUB_WORKSPACE=$(pwd)
            CHART_GITHUB_LOCATION=$GITHUB_WORKSPACE
            TEMPLATE_REPO_GITHUB_LOCATION=$GITHUB_WORKSPACE/../convoy-helm-template
            echo "$CHART_GITHUB_LOCATION"
            echo "$TEMPLATE_REPO_GITHUB_LOCATION"
            echo "TEMPLATE_REPO_GITHUB_LOCATION=$TEMPLATE_REPO_GITHUB_LOCATION"
            echo "Cloning convoy-helm-template"
            rm -rf $TEMPLATE_REPO_GITHUB_LOCATION
            template_version=$(yq --exit-status '.convoy-helm-template' Chart.yaml)
            if [ $? -eq 0 ]; then
                echo "convoy-helm-template version: $template_version"
            else
                echo "convoy-helm-template version not found.Exiting."
                exit 1
            fi
            git clone --branch $template_version https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com/${{github.repository_owner}}/convoy-helm-template.git $TEMPLATE_REPO_GITHUB_LOCATION
            echo "Copying the service values file"
            cp -r $CHART_GITHUB_LOCATION/services/* $TEMPLATE_REPO_GITHUB_LOCATION/helm-chart/values/apps/
            cp -r $CHART_GITHUB_LOCATION/Chart.yaml $TEMPLATE_REPO_GITHUB_LOCATION/helm-chart/Chart.yaml
            set -e
            cd $TEMPLATE_REPO_GITHUB_LOCATION/scripts
            ls -lrta ../helm-chart/values/apps/
          }
          configureJava() {
            echo "JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64" >> $GITHUB_ENV
            echo "PATH=/usr/lib/jvm/java-17-openjdk-amd64/bin:$PATH" >> $GITHUB_ENV
          }
          dbPluginBuildAndPush() {
            set -e
            ARTIFACT="$1"
            EXTENSION="$2"
            requiredInputs="1 2"
            validateInputs "$requiredInputs" "$@" 
            installPythonDependencies $ARTIFACT
            if [ -f ./$ARTIFACT/requirements.txt ]; then python -m pip install -r ./$ARTIFACT/requirements.txt --dry-run --trusted-host ${{env.NEXUS_SERVER_ENDPOINT}} --extra-index-url=${{env.NEXUS_PROTOCOL}}://${{ secrets.CIPIPELINE_NEXUS_USERNAME }}:${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}@${{env.NEXUS_SERVER_ENDPOINT}}/repository/${{ env.NEXUS_PULL_REPOS_PY }}/simple; fi
            gradlewUploadPlugin
            PLUGIN_NAME=$(echo "$ARTIFACT" | tr '-' '_')
            mv "$ARTIFACT/build/$PLUGIN_NAME-${LATEST_TAG}.$EXTENSION" "$ARTIFACT.$EXTENSION"
            awsConfigureProdAssets
            push_release_manifest_artifacts
            set +e
          }
          functionBuildAndPush() {
            set -e
            ARTIFACT="$1"
            EXTENSION="$2"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            changed_dir=false
            if [ ! -f "Makefile" ]; then
              cd tessell; 
              changed_dir=true;
            fi
            OS=$(echo "$ARTIFACT" | awk -F'[-]' '{print $4}')
            CLOUD=$(echo "$ARTIFACT" | awk -F'[-]' '{print $5}')
            make OS=$OS CLOUD=$CLOUD nexus_protocol=${{env.NEXUS_PROTOCOL}} nexus_server_endpoint=${{env.NEXUS_SERVER_ENDPOINT}} package
            awsConfigureProdAssets
            mvnDeploy "$ARTIFACT" "tar" "$ARTIFACT.tar" "tessell.functions" "${LATEST_TAG}"
            push_release_manifest_artifacts
            if $changed_dir; then
              cd ..;
            fi
            set +e
          }
          gradlewMaven() {
            ./gradlew mavenDeploy --console plain --refresh-dependencies \
              -Pnexus_push_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_push_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_push_repo_m2="${{ env.NEXUS_PUSH_REPOS_M2 }}" \
              -Pnexus_pull_repo_m2="${{ env.NEXUS_PULL_REPOS_M2 }}"
          }
          gradlewMavenDocker() {
            ./gradlew mavenPackage dockerTag --console plain \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_pull_repo_m2="${{ env.NEXUS_PULL_REPOS_M2 }}" \
              -Pdockerhub_org="${{ env.DOCKERHUB_ORG }}"
          }
          gradlewTwineUpload() {
            ./gradlew twineUpload --console plain \
              -Pnexus_push_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_push_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_push_repo_py="${{ env.NEXUS_PUSH_REPOS_PY }}" \
              -Pnexus_pull_repo_py="${{ env.NEXUS_PULL_REPOS_PY }}" 
          }
          gradlewUploadPlugin() {
            ./gradlew createMvnSettings uploadPlugin --console plain \
              -Pnexus_push_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_push_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_username="${{ secrets.CIPIPELINE_NEXUS_USERNAME }}" \
              -Pnexus_password="${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}" \
              -Pnexus_push_repo_m2="${{ env.NEXUS_PUSH_REPOS_M2 }}" 
          }
          helmChartBuildAndPush() {
            set -e
            CHART_NAME="$1"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            cd scripts
            if ${DEV_BUILD}; then
              ./package-and-push -f -n $CHART_NAME -v "0.0.0-${DISPATCH_BRANCH_NAME}"
            else
              ./package-and-push --prod -n $CHART_NAME -v ${LATEST_TAG}
            fi
            cd ..
            set +e
          }
          helmTemplateBuildAndPush() {
            # if [[ ${{steps.changed-files.outputs.any_modified}} == 'true' ]]; then
            set -e
            CHART_NAME="$1"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            cloneHelmTemplate
            echo "Running package and push"
            if ${DEV_BUILD}; then
              ./package-and-push -f -n $CHART_NAME -v "0.0.0-${DISPATCH_BRANCH_NAME}"
            else
              ./package-and-push --prod -n $CHART_NAME -v ${LATEST_TAG}
            fi
            cd $GITHUB_WORKSPACE
            set +e
            # fi
          }
          installPythonDependencies() {
            DIR=$1
            if [[ -z "${DIR}" ]]; then
              DIR='.'
            fi
            python -m pip install --upgrade pip
            python -m pip install flake8 pytest twine wheel
            if [ -f "${DIR}/requirements.txt" ]; then
              python -m pip install -r "${DIR}/requirements.txt" --trusted-host ${{env.NEXUS_SERVER_ENDPOINT}} --extra-index-url=${{env.NEXUS_PROTOCOL}}://${{ secrets.CIPIPELINE_NEXUS_USERNAME }}:${{ secrets.CIPIPELINE_NEXUS_PASSWORD }}@${{env.NEXUS_SERVER_ENDPOINT}}/repository/${{ env.NEXUS_PULL_REPOS_PY }}/simple;
            fi
          }
          javaApiClientBuildAndPush() {
            set -e
            mvn deploy -Drevision=${LATEST_TAG} -Dnexus-url=${NEXUS_PROTOCOL}://${NEXUS_SERVER_ENDPOINT}/repository/${NEXUS_PUSH_REPOS_M2}
            set +e
          }
          javaDockerBuildAndPush() {
            set -e
            IMAGE="$1"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            configureJava
            gradlewMavenDocker
            docker push ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG}
            set +e
          }
          javaLibraryBuildAndPush() {
            set -e
            configureJava
            gradlewMaven
            set +e
          }
          lintCheck() {
            flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
            flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
          }
          makeBuildAndPush() {
            set -e
            installGoDependencies
            make service
            ARTIFACT="$1"
            EXTENSION="$2"
            OS=$(echo "$ARTIFACT" | awk -F'[-]' '{print $3}')
            make os=$OS pushprox-client
            make clean
            ls -lrta client-package
            mvnDeploy "$ARTIFACT" "$EXTENSION" "client-package/$ARTIFACT.$EXTENSION" "tessell.pushprox" "${LATEST_TAG}"
            awsConfigureProdAssets
            push_release_manifest_artifacts "${ARTIFACT}.${EXTENSION}" "client-package/${ARTIFACT}.${EXTENSION}"
            set +e
          }
          makeImageAndPush() {
            set -e
            IMAGE="$1"
            make image
            docker tag $IMAGE:latest ${{env.DOCKERHUB_ORG}}/$IMAGE:${LATEST_TAG}
            docker push ${{env.DOCKERHUB_ORG}}/$IMAGE:${LATEST_TAG}
            set +e
          }
          modifiedDir() {
            directories=$(echo ${{steps.changed-files-all.outputs.all_changed_and_modified_files}} | tr ' ' '\n' | awk -F'/' '{print $1}' | sort -u)
            directories=$(echo $directories | tr '\n' ' ')
            echo "$directories"
          }
          opsImageBuildAndPush() {
            set -e
            ./mvnw install -Dnative -DskipTests -Dquarkus.native.remote-container-build=true
            dockerBuildAndPush "$@"
            set +e
          }
          opaBuildAndPush() {
            set -e
            ARTIFACT="$1"
            EXTENSION="$2"
            requiredInputs="1 2"
            file_name="${ARTIFACT}.${EXTENSION}"
            validateInputs "$requiredInputs" "$@" 
            setupOpa
            mkdir -p bundles
            if [[ $ARTIFACT == *"wasm"* ]]; then
              ~/opa build -t wasm policies --output bundles/${file_name}
            else
              ~/opa build policies --output bundles/${file_name}
            fi
            push_release_manifest_artifacts ${file_name} "bundles/${file_name}"
            set +e
          }
          pythonApiClientBuildAndPush() {
            set -e
            bash setup --version ${LATEST_TAG} --upload
            set +e
          }
          pythonApiTemplatesBuildAndPush() {
            set -e
            ARTIFACT="$1"
            EXTENSION="$2"
            requiredInputs="1 2"
            validateInputs "$requiredInputs" "$@" 
            ARTIFACT_FILE="${ARTIFACT}.${EXTENSION}"
            zipDirectory "openapi-templates" "${ARTIFACT_FILE}"
            mvnDeploy "$ARTIFACT" "$EXTENSION" "./${ARTIFACT_FILE}" "com.tessell" "${LATEST_TAG}"
            set +e
          }
          pythonLibraryBuildAndPush() {
            set -e
            ARTIFACT="$1"
            requiredInputs="1"
            validateInputs "$requiredInputs" "$@" 
            installPythonDependencies $ARTIFACT
            lintCheck
            gradlewTwineUpload
            set +e
          }
          setupOpa() {
            curl -L -o ~/opa https://openpolicyagent.org/downloads/v0.61.0/opa_linux_amd64_static
            chmod 755 ~/opa
            curl -L -o ~/opa_darwin_amd64 https://openpolicyagent.org/downloads/v0.61.0/opa_darwin_amd64
            curl -L -o ~/opa_darwin_amd64.sha256 https://openpolicyagent.org/downloads/v0.61.0/opa_darwin_amd64.sha256
            ~/opa version
          }
          terraformBuildAndPush() {
            set -e
            BASE_DIR=$PWD
            BUILD_DIR=$BASE_DIR/build
            mkdir -p $BUILD_DIR
            DIRECTORIES=($(ls -d */))
            EXCLUDE_DIR=("build",".github",".gitignore","convoy.yaml","README.md","ci-scripts")
            MODIFIED_DIRECTORIES=$(modifiedDir)
            if [[ "${{github.event_name}}" == "workflow_dispatch" && !${{inputs.dev_build}} ]]; then
              MODIFIED_DIRECTORIES=${DIRECTORIES[@]}
            fi
            if [[ ${BASE_BRANCH} == 'main' ]]; then
              manifestLabel="latest-main"
            else 
              manifestLabel="${LABEL}"
            fi
            releaseManifest=$(curl --silent --location "${{env.RELEASE_MANIFEST_URL}}/${manifestLabel}")
            for DIR in "${DIRECTORIES[@]}"; do
              CHECKSUM=""
              DIR=${DIR%/}
              if [[ ! " $MODIFIED_DIRECTORIES " =~ " $DIR " && " ${EXCLUDE_DIR[*]} " != *"$DIR"* ]]; then
                CHECKSUM=$(echo "$releaseManifest" | jq -r ".artifacts[\"${DIR}\"].checksum // empty")
                if [[ -n ${CHECKSUM} ]]; then
                  echo "Checksum already present in release manifest for tf module: ${DIR}."
                  ARTIFACT_CHECKSUMS+="${DIR}:${CHECKSUM}%"           
                else
                  echo "Checksum not present in release manifest for tf-module: ${DIR}. Building the module and generating checksum."
                  ARTIFACT_FILE="${DIR}.zip"
                  cd $BASE_DIR/$DIR
                  VERSION=$(yq .version convoy.yaml)
                  terraform_build $PWD $BUILD_DIR/$ARTIFACT_FILE
                  cd $BASE_DIR
                  generateChecksum "$ARTIFACT_FILE"
                fi
              fi
            done
            for DIR in $MODIFIED_DIRECTORIES
            do
              DIR=${DIR%/}
              if [[ " ${EXCLUDE_DIR[*]} " != *"$DIR"* ]]; then 
                ARTIFACT_FILE=${DIR}.zip
                cd $BASE_DIR/$DIR
                VERSION=$(yq .version convoy.yaml)
                download_binary_from_source
                terraform_build $PWD $BUILD_DIR/$ARTIFACT_FILE
                cd $BASE_DIR
                generateChecksum "$ARTIFACT_FILE"
                ARTIFACT_FILE=$BUILD_DIR/${DIR}.zip
                pushTerraformModules
              fi
            done
            ls -lrta $BUILD_DIR
            set +e
          }
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            git config --global url."https://${GITHUB_USER}:${GITHUB_TOKEN}@github.com".insteadOf "https://github.com"
            version=$(yq '.version // ""' convoy.yaml)
            language=$(yq '.language // ""' convoy.yaml)
            environments=("dev" "qa" "stage" "prod")
            if [[ "$language" == "terraform" ]]; then
              terraformBuildAndPush
              return
            fi
            yq e ".generates.$type[] | [.name, .buildAndPushFunction, .buildFunction, .buildTool, .extension, .dockerFile] | @csv" convoy.yaml | sed 's/null//g' > artifacts.txt
            lineNumber=1
            while :; do
              echo ------------------------------
              artifactData=$(sed "${lineNumber}!d" artifacts.txt)
              if [[ -z "${artifactData}" ]]; then
                break
              fi

              set -x
              java_version=$(yq '.javaVersion // ""' convoy.yaml)
              if [[ -n ${java_version:-} ]]; then
                if [[ -d /usr/lib/jvm/java-${java_version}-openjdk-amd64 ]]; then
                  export JAVA_HOME=/usr/lib/jvm/java-${java_version}-openjdk-amd64
                  export PATH="/usr/lib/jvm/java-${java_version}-openjdk-amd64/bin:${PATH}"
                else
                  echo "Java Version ${java_version}, as required in convoy.yaml, is not installed"
                  exit 1
                fi
              fi

              IFS=',' read -r name buildAndPushFunction buildFunction buildTool ext file <<< "${artifactData}"
              export ARTIFACT_NAME=${name} ARTIFACT_EXTENSION=${ext} ARTIFACT_VERSION=${version} DOCKERFILE_PATH=${file}
              echo "Name: ${name}"
              echo "buildAndPushFunction: ${buildAndPushFunction}"
              echo "buildFunction: ${buildFunction}"
              echo "buildTool: ${buildTool}"
              echo "Ext: ${ext}"
              echo "Version: ${version}"
              echo "dockerFile: ${file}"

              if [[ -n ${buildAndPushFunction:-} ]]; then
                set -e
                ${buildAndPushFunction}
                set +e
              elif [[ -n ${buildFunction} ]]; then
                ${buildFunction}AndPush ${name} ${ext} ${version} ${file}
              elif [[ -n ${buildTool:-} ]]; then
                set -e
                $(yq .post-merge.${buildTool} ./ci-scripts/bash/build-tool-cmd-map.yaml)
                set +e
              fi
              set +x

              echo "$type $name done"
              echo ------------------------------
              lineNumber=$((lineNumber+1))
            done
            rm artifacts.txt
          }
          set +e
          echo GIT_BASE_REF: ${GIT_BASE_REF}
          source ./ci-scripts/bash/functions-for-build
          ARTIFACT_CHECKSUMS=""
          BRANCH_COVERAGE=""
          STATEMENT_COVERAGE=""
          configureGoVersionIfRequired
          echo "Executing pre-merge command"
          set -e; bash -c "$(yq ".ci.${CI_PHASE}.cmd // \"\"" convoy.yaml)"; set +e
          build "artifacts"
          build "dockerImages"
          build "helmCharts"
          build "terraform"
          build "softwareImages"
          parseAndPushCoverageReport

          # the file CONTENT_FOR_GITHUB_OUTPUT may contain GENERATED_ARTIFACTS with a stringified json as its value
          [[ ! -s ${CONTENT_FOR_GITHUB_OUTPUT} ]] || echo 'IS_CONTENT_FOR_GITHUB_OUTPUT_POPULATED="true"' >> $GITHUB_OUTPUT
          echo "ARTIFACT_CHECKSUMS=$ARTIFACT_CHECKSUMS" >> $GITHUB_OUTPUT
          echo "BRANCH_COVERAGE=$BRANCH_COVERAGE" >> $GITHUB_OUTPUT
          echo "STATEMENT_COVERAGE=$STATEMENT_COVERAGE" >> $GITHUB_OUTPUT
          echo "GITHUB OUTPUT:"
          cat $GITHUB_OUTPUT

      - uses: actions/upload-artifact@v4
        name: Export content for github output as artifact
        if: ${{ env.IS_CONTENT_FOR_GITHUB_OUTPUT_POPULATED == 'true' }}
        # continue-on-error: true
        with:
          name: generated-artifacts
          path: ${{env.CONTENT_FOR_GITHUB_OUTPUT}}

      - name: Cleanup
        if: always()
        run: |
          set +e
          sudo rm -rf target
          helm repo remove nexus-prod
          docker container prune --force
          docker volume prune --force
                  
      # - name: Slack Notification
      #   uses: act10ns/slack@v2.0.0
      #   if: failure()
      #   with:
      #     status: ${{ job.status }}
      #     steps: ${{ toJson(steps) }}
      #     channel: ${{ secrets.SLACK_DEVOPS_CHANNEL }}
      
  build-arm:
    if: ${{ inputs.type == 'arm' }}
    runs-on: ARM64
    outputs:
      ARTIFACT_CHECKSUMS: ${{ steps.build.outputs.ARTIFACT_CHECKSUMS }}
      BRANCH_COVERAGE: ${{ steps.build.outputs.BRANCH_COVERAGE }}
      STATEMENT_COVERAGE: ${{ steps.build.outputs.STATEMENT_COVERAGE }}
    env:
      ARTIFACTS_DEV_ACCESS_KEY: ${{ secrets.ARTIFACTS_DEV_ACCESS_KEY }}
      ARTIFACTS_DEV_SECRET_KEY: ${{ secrets.ARTIFACTS_DEV_SECRET_KEY }}
      ARTIFACTS_DEV_S3: ${{vars.ARTIFACTS_DEV_S3}}
      ARTIFACTS_UPLOAD_ACCESS_KEY: ${{ secrets.ARTIFACTS_UPLOAD_ACCESS_KEY }}
      ARTIFACTS_UPLOAD_SECRET_KEY: ${{ secrets.ARTIFACTS_UPLOAD_SECRET_KEY }}
      BASE_BRANCH: "${{github.event.pull_request.base.ref}}"
      CI_BRANCH: TDEVOPS-3633_convoy_ci_on_3693_test
      CODE_COVERAGE_S3: ${{vars.CODE_COVERAGE_S3}}
      DEV_BUILD: ${{inputs.dev_build}}
      CONVOY_API_KEY: ${{secrets.CONVOY_AUTH_TOKEN}}
      DEVQA_INFRA_ACCESS_KEY: ${{ secrets.DEVQA_INFRA_ACCESS_KEY }}
      DEVQA_INFRA_SECRET_KEY: ${{ secrets.DEVQA_INFRA_SECRET_KEY }}
      DOCKERHUB_ORG: ${{vars.DOCKERHUB_ORG}}
      GITHUB_TOKEN: ${{ secrets.CIPIPELINE_GITHUB_TOKEN }}
      GITHUB_USER: ${{ secrets.CIPIPELINE_GITHUB_USER }}
      IMAGE_SCAN_API_URL: http://${{vars.CONVOY_DEV_API_ENDPOINT}}/devops/code/vulnerabilities/validate
      LABEL: ${{inputs.label}}
      LATEST_TAG: ${{inputs.tag}}
      NEXUS_ARTIFACT_REPO: ${{vars.NEXUS_REPO_TESSELL_ARTIFACTS}}
      NEXUS_PASSWORD: ${{secrets.CIPIPELINE_NEXUS_PASSWORD}}
      NEXUS_PROTOCOL: ${{vars.NEXUS_PROTOCOL_LOCAL}}
      NEXUS_PULL_REPOS_M2: tessell-m2-development
      NEXUS_PULL_REPOS_PY: tessell-py-development
      NEXUS_PUSH_REPOS_M2: ${{ vars.NEXUS_PUSH_REPOS_M2 }}
      NEXUS_PUSH_REPOS_PY: ${{ vars.NEXUS_PUSH_REPOS_PY }}
      NEXUS_PUSH_REPOS_NPM: ${{vars.NEXUS_PUSH_REPOS_NPM}}
      NEXUS_REPO_TESSELLOPS_ARTIFACTS: ${{vars.NEXUS_REPO_TESSELLOPS_ARTIFACTS}}
      NEXUS_SERVER_ENDPOINT: ${{vars.NEXUS_SERVER_ENDPOINT_LOCAL}}
      NEXUS_USERNAME: ${{secrets.CIPIPELINE_NEXUS_USERNAME}}
      PROD_ASSET_ACCESS_KEY: ${{ secrets.PROD_ASSET_ACCESS_KEY }}
      PROD_ASSET_SECRET_KEY: ${{ secrets.PROD_ASSET_SECRET_KEY }}
      REPO: "${{github.event.pull_request.base.repo.name}}"
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      TESSELL_ARTIFACTS_PROD_ASSETS_S3: ${{vars.TESSELL_ARTIFACTS_PROD_ASSETS_S3}}
      TESSELL_GCP_APP_NAME: ${{ vars.TESSELL_GCP_APP_NAME }}
      TESSELL_GCP_ARTIFACTS_BUCKET: ${{ vars.TESSELL_GCP_ARTIFACTS_BUCKET }}
      TESSELL_GCP_DOCKERHUB_ORG: ${{vars.TESSELL_GCP_DOCKERHUB_ORG}}
      TESSELL_GCP_PROJECT_ID: ${{vars.TESSELL_GCP_PROJECT_ID}}
      TESSELL_GCP_REGION: ${{vars.TESSELL_GCP_REGION}}
      TESSELL_GCP_SERVICE_ACCOUNT_NAME: ${{vars.TESSELL_GCP_SERVICE_ACCOUNT_NAME}}
      TESSELLOPS_ARTIFACTS_DEV_S3: ${{vars.TESSELLOPS_ARTIFACTS_DEV_S3}}
      TESSELLOPS_ARTIFACTS_DEV_ACCESS_KEY: ${{ secrets.TESSELLOPS_ARTIFACTS_DEV_ACCESS_KEY }}
      TESSELLOPS_ARTIFACTS_DEV_SECRET_KEY: ${{ secrets.TESSELLOPS_ARTIFACTS_DEV_SECRET_KEY }}
    steps: 

      - name: Set Repositories for Dev Build
        if: ${{ inputs.dev_build }}
        run: |
          echo "DOCKERHUB_ORG=tesselldev" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_M2=tessell-repos-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_NPM=tessell-repos-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PUSH_REPOS_PY=tessell-repos-py-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_M2=tessell-m2-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_NPM=tessell-npm-development" >> $GITHUB_ENV
          echo "NEXUS_PULL_REPOS_PY=tessell-py-development" >> $GITHUB_ENV
          echo "TESSELL_ARTIFACTS_PROD_ASSETS_S3=tesselltools-dev" >> $GITHUB_ENV

      - name: Checkout code
        uses: actions/checkout@v4.1.1
        with:
          fetch-depth: 0

      - name: Set Application Name
        run: |
          export APP_GROUP=$(yq '.appGroup // "tessell"' convoy.yaml)
          echo "APP_GROUP=$APP_GROUP" >> $GITHUB_ENV
          if [[ ${APP_GROUP} == ${TESSELL_GCP_APP_NAME} ]]; then
            export DOCKERHUB_ORG=$TESSELL_GCP_REGION-docker.pkg.dev/$TESSELL_GCP_PROJECT_ID/$TESSELL_GCP_DOCKERHUB_ORG
            echo "DOCKERHUB_ORG=$DOCKERHUB_ORG" >> $GITHUB_ENV
          fi

      - name: Setup CI Scripts
        run: |
          cd ~/convoy-ci
          git checkout main
          git pull
          git checkout ${{env.CI_BRANCH}}
          git pull
          cd ~-
          cp -r ~/convoy-ci/.github/ci-scripts ./ci-scripts

      - name: Login to Docker
        run : |
          docker login -u="${{ secrets.DOCKER_USERNAME }}" -p="${{ secrets.DOCKER_PASSWORD }}"

      - name: Login gcloud
        id: auth
        if: ${{ env.APP_GROUP == env.TESSELL_GCP_APP_NAME }}
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.TESSELL_GCP_SERVICE_ACCOUNT_KEY_JSON }}'
          token_format: access_token
          create_credentials_file: true

      - name: Login to Artifact Registry
        if: ${{ env.APP_GROUP == env.TESSELL_GCP_APP_NAME }}
        uses: docker/login-action@v1
        with:
          registry: ${{vars.TESSELL_GCP_REGION}}-docker.pkg.dev 
          username: oauth2accesstoken
          password: ${{ steps.auth.outputs.access_token }}

      - name: Build and Push OPS
        id: build
        shell: bash
        run: |
          dockerMultiBuildAndPush() {
            awsConfigureDevqaInfra
            docker buildx rm multi-platform-builder
            docker buildx create --use --platform=linux/arm64,linux/amd64 --name multi-platform-builder
            set -e
            aws ecr get-login-password --region ap-south-1 | docker login --username AWS --password-stdin ${{vars.TESSELL_DEV_ECR}}
            IMAGE="$1"
            FILE="$4"
            requiredInputs="1 4"
            validateInputs "$requiredInputs" "$@" 
            docker buildx build --push -f $FILE --no-cache -t ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG} --platform=linux/amd64,linux/arm64 .
            docker build --push -f $FILE --no-cache -t ${{vars.TESSELL_DEV_ECR}}/$IMAGE:${LATEST_TAG} .
            set +e
          }
          dockerMilvusBuildAndPush() {
            awsConfigureDevqaInfra
            docker buildx rm multi-platform-builder
            docker buildx create --use --platform=linux/arm64,linux/amd64 --name multi-platform-builder
            set -e
            aws ecr get-login-password --region ap-south-1 | docker login --username AWS --password-stdin ${{vars.TESSELL_DEV_ECR}}
            IMAGE="$1"
            AGENT_VERSION=$(yq '.tessellAgentVersion' convoy.yaml)
            TASKHANDLER_VERSION=$(yq '.taskHandlerVersion' convoy.yaml)
            docker buildx build --push --no-cache --platform linux/amd64 \
                                -t ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG} \
                                -t ${{ vars.TESSELL_DEV_ECR }}/$IMAGE:${LATEST_TAG} \
                                --build-arg HANDLER_TAG=$TASKHANDLER_VERSION \
                                --build-arg AGENT_TAG=$AGENT_VERSION \
                                --build-arg NEXUS_USERNAME=${{ secrets.CIPIPELINE_NEXUS_USERNAME }} \
                                --build-arg NEXUS_PASSWORD=${{ secrets.CIPIPELINE_NEXUS_PASSWORD }} \
                                --build-arg GITHUB_USER=${{ secrets.CIPIPELINE_GITHUB_USER }} \
                                --build-arg GITHUB_TOKEN=${{ secrets.CIPIPELINE_GITHUB_TOKEN }} \
                                --build-arg NEXUS_PROTOCOL=${NEXUS_PROTOCOL} \
                                --build-arg NEXUS_SERVER_ENDPOINT=${NEXUS_SERVER_ENDPOINT} .
            set +e
          }
          dockerPullAndPush() {
            set -e
            IMAGE="$1"
            requiredInputs="1 2 3"
            validateInputs "$requiredInputs" "$@" 
            VERSION=$(yq e ".consumes.dockerImages[] | select(.name == \"$IMAGE\") | .version" convoy.yaml)
            docker pull ${DOCKERHUB_ORG}/$IMAGE:$VERSION
            docker tag ${DOCKERHUB_ORG}/$IMAGE:$VERSION ${{vars.TESSELL_DEV_ECR}}/$IMAGE:${LATEST_TAG}
            docker push ${{vars.TESSELL_DEV_ECR}}/$IMAGE:${LATEST_TAG} 
            docker buildx imagetools create -t ${DOCKERHUB_ORG}/$IMAGE:${LATEST_TAG} ${DOCKERHUB_ORG}/$IMAGE:$VERSION
            set +e
          }
          build() {
            type="$1"
            check=$(grep "$type" convoy.yaml)
            if [[ -z "$check" ]]; then
              return
            fi
            version=$(yq '.version' convoy.yaml)
            environments=("dev" "qa" "stage" "prod")
            yq e ".generates.$type[] | [.name, .buildFunction, .extension, .dockerFile] | @csv" convoy.yaml | sed 's/,/ /g' > artifacts.txt
            lineNumber=1
            while :; do
              echo ------------------------------
              artifactData=$(sed "$lineNumber!d" artifacts.txt)
              if [[ -z "$artifactData" ]]; then
                break
              fi
              read -r name buildFunction ext file <<< "$artifactData"
              echo "Name: $name"
              echo "buildFunction: $buildFunction"
              echo "Ext: $ext"
              echo "Version: $version"
              echo "dockerFile: $file"
              "${buildFunction}AndPush" $name $ext $version $file 
              echo "$type $name done"
              echo ------------------------------
              lineNumber=$((lineNumber+1))
            done
            rm artifacts.txt
          }
          set +e
          source ./ci-scripts/bash/functions-for-build
          ARTIFACT_CHECKSUMS=""
          BRANCH_COVERAGE=""
          STATEMENT_COVERAGE=""
          build "artifacts"
          build "dockerImages"
          build "helmCharts"
          parseAndPushCoverageReport
          echo "ARTIFACT_CHECKSUMS=$ARTIFACT_CHECKSUMS" >> $GITHUB_OUTPUT
          echo "BRANCH_COVERAGE=$BRANCH_COVERAGE" >> $GITHUB_OUTPUT
          echo "STATEMENT_COVERAGE=$STATEMENT_COVERAGE" >> $GITHUB_OUTPUT

      - name: Cleanup
        if: always()
        run: |
          set +e
          sudo rm -rf target
          helm repo remove nexus-prod
          docker container prune --force
          docker volume prune --force
                    
      # - name: Slack Notification
      #   uses: act10ns/slack@v2.0.0
      #   if: failure()
      #   with:
      #     status: ${{ job.status }}
      #     steps: ${{ toJson(steps) }}
      #     channel: ${{ secrets.SLACK_DEVOPS_CHANNEL }}
